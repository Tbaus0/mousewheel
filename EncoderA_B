#include <Encoder.h>

#define ENCODER_A 2  // Quadrature signal A (Interrupt pin)
#define ENCODER_B 4  // Quadrature signal B (Regular pin)
#define INDEX_PIN 3  // Index pulse (Z) (Interrupt pin)

volatile long lastIndexTime = 0;  // Timestamp of last index pulse
volatile float vel = 0.0;         // Revolutions per second
volatile int direction = 1;       // 1 = CW, -1 = CCW
volatile int oldPosition = 0;
const int pause = 100;        //miliseconds of pause per loop


Encoder myEnc(ENCODER_A, ENCODER_B);
long lastPosition = 0;  // Stores encoder position from last index pulse

void indexISR() {
  // example: track revolutions-per-second on the INDEX_PIN
  unsigned long now = millis();
  unsigned long dt  = now - lastIndexTime;  
  if (lastIndexTime > 0 && dt > 0) {
    // one index pulse per rev → direction×(1000 ms/s)/dt rps
    vel       = direction * (1000.0 / dt);
    lastIndexTime = now;
  }
  // optionally read the encoder to set direction:
  direction = (myEnc.read() - oldPosition > 0) ? 1 : -1;
}


void setup() {
    Serial.begin(9600);

    pinMode(INDEX_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(INDEX_PIN), indexISR, RISING);
}

void loop() {
    long newPosition = myEnc.read();  // Read encoder position

    Serial.print("Position (cm): ");
    Serial.print(newPosition/158.607);
    Serial.print("\t Velocity (cm/s): ");
    Serial.print(vel);
    Serial.print("\t Direction: ");

    if (direction == 1) {  // Show Direction
      Serial.println("CW");
    } else {
      Serial.println("CCW");
    }

    vel = (newPosition - oldPosition) * 1000.0 / pause;    //change in position over the delay period
    oldPosition = newPosition;

    delay(pause);  // Update rate
}
